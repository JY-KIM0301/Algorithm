# 백준 9465: 스티커

https://www.acmicpc.net/problem/9465

## 문제

상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.

상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.

각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.  
**예제 입력**

```
2
5
50 10 100 20 40
30 50 70 10 60
7
10 30 10 50 100 20 40
20 40 30 50 60 20 80
```

**예제 출력**

```
260
290
```

## 풀이 코드

```python
test_case = int(input())

for _ in range(test_case):
  n = int(input())
  dp = []
  # 2차원 배열 생성
  for _ in range(2):
    dp.append(list(map(int, input().split())))
  dp[0][1] = dp[1][0] + dp[0][1]
  dp[1][1] = dp[0][0] + dp[1][1]

  for i in range(2, n):
    dp[0][i] = max(dp[1][i-1], dp[1][i-2]) + dp[0][i]
    dp[1][i] = max(dp[0][i-1], dp[0][i-2]) + dp[1][i]
  print(max(dp[0][n-1], dp[1][n-1]))

```

## 풀이 과정

2차원 리스트를 순서대로 입력해주고, 1번 인덱스에서는 무조건 0번째 대각선에 있는 숫자와 합해줘야 하기 때문에 초기식으로 설정해주었고, 2번째 인덱스부터는 왼쪽 대각선 혹은 전전 왼쪽 대각선 숫자 중에 큰 값을 더해줘야 최종 인덱스에 합계의 최댓값이 나올 것이다. <br><br>
n=5일때 테스트 케이스를 보면, dp[i][2]일때 부터 대각선 방향뿐만 아니라, 대각선 방향의 옆에 있는 숫자와 비교해서 둘중 큰수를 가져와 dp[i][2]와 더해줘야한다. 단순히 대각선끼리만 더해서 두가지 경우중 최댓값을 구하는게 아닌 문제. 첫번째 케이스만 해도 마지막에 10이 아닌 60을 선택해야 최대합이 나온다.
