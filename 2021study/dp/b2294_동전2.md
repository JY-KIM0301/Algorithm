# 백준 2294: 동전2

https://www.acmicpc.net/problem/2294

## 문제

n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.
첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 가치가 같은 동전이 여러 번 주어질 수도 있다. <br><br>
**예제 입력**

```
3 15
1
5
12
```

**예제 출력**  
첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.

```
3
```

## 풀이 코드

```python
n, k = map(int, input().split())
coin = []

for i in range(n):
    coin.append(int(input()))
coin.sort()
dp = [10001] * (k+1)
dp[0] = 0
for i in range(n):
    for j in range(coin[i], k+1):
      dp[j] = min(dp[j-coin[i]]+1, dp[j])
if dp[k] != 10001:
    print(dp[k])
else:
    print(-1)
```

## 풀이 과정

동전의 종류를 입력받는 배열 coin과, k를 만들수 있는 동전의 개수를 저장할 배열 dp를 생성해준다. 문제에서 k의 최댓값은 10000라고 했으므로 dp배열을 10001로 초기화 해주었다.<br><br>
dp[0]은 0을 만들 수 없으므로 0이라고 먼저 설정해주고, dp[1]부터 계속 구해보았다.  
|k|dp[k]|
|:---:|:---:|
|1|1|
| 2 | 2|
| 3 | 3|
| 4 | 4|
| 5 | 1|
| 6 | 2|
...
| 10 | 2|
| 11 | 3|
| 12 | 1|
| 13 | 2|
| 14 | 3|
| 15 | 3|  
<br><br>
dp의 점화식은 `dp[i] = min(dp[k-coin]+1, dp[k])` 라고 할수있다.  
예제에서 동전의 종류가 1, 5, 12이므로 이 경우에는 dp[k]에서 dp[k-1], dp[k-5], dp[k-12] 중에서 가장 작은값을 빼주고, 1을 더하면 최소값을 구할 수 있게된다.
k가 1, 5, 12일때를 각각 비교해보고 규칙을 찾을 수 있었고,, 한눈에 보이진 않았음
