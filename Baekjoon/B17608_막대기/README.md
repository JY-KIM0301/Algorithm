# 백준 17608: 막대기

https://www.acmicpc.net/problem/17608

## 문제

높이만 다르고 (같은 높이의 막대기가 있을 수 있음) 모양이 같은 막대기를 일렬로 세운 후, 왼쪽부터 차례로 번호를 붙인다. 각 막대기의 높이는 그림에서 보인 것처럼 순서대로 6, 9, 7, 6, 4, 6 이다. 일렬로 세워진 막대기를 오른쪽에서 보면 보이는 막대기가 있고 보이지 않는 막대기가 있다. 즉, 지금 보이는 막대기보다 뒤에 있고 높이가 높은 것이 보이게 된다. 예를 들어, 그림과 같은 경우엔 3개(6번, 3번, 2번)의 막대기가 보인다. 오른쪽에서 보아서 몇 개가 보이는지를 알아내는 프로그램을 작성하려고 한다. 첫번째줄 입력은 테스트케이스

**예제 입력**

```
6
6
9
7
6
4
6
```

**예제 출력**

```
3
```

## 풀이 코드

```python
import sys

N = int(sys.stdin.readline())
data = []  # 배열 생성

for _ in range(N):
  data.append(int(sys.stdin.readline()))
  # 입력받은 데이터를 배열에 저장

target = data[-1]
answer = 1

for i in range(N-1, -1, -1):
  if data[i] > target:
    target = data[i]
    answer += 1

print(answer)


```

## 풀이 과정

일렬로 세운 막대기중, 오른쪽에서 보았을때 보이는 개수를 출력해야 하므로 가장 오른쪽 막대기를 기준으로 하나씩 관찰한다. target 막대기와 인접한 막대기와 비교하여 인접한 막대기가 크다면, 초기값 1이 들어있는 answer에 +1 연산을 수행한다. 가장 오른쪽 막대기는 무조건 보이기 때문에 answer = 1로 초기화 해줌.<br> 또한, 큰 경우에는 해당 큰 막대기가 target이 되어 다시 왼쪽 막대기와 크기를 비교한다. 반복!! <br><br>
`target = data[-1]` 이부분은 [-1] 대신 [N-1]이라고 해도 가능. 배열 인덱싱 까먹어서 배열안에 음수라고??했는데 크기 N인 배열에서 배열[-1]은 배열[4]와 같다.. 맨끝 인덱스 반환!!
